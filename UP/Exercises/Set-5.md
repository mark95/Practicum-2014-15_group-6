SET - 5
============

### Задача 1 ###

Да се напише програма, коята въвежда координатите на точка и проверява дали тя се съдържа в запълнената [фигура](http://img5.imageshack.us/img5/2737/wiwv.png)(това включва и контура, отбелязан с черни непрекъснати линии, но не включва този отбелязан с червени прекъснати линии).

#### Пояснение ####

Припомнете си [закона на Де Морган](http://en.wikipedia.org/wiki/De_Morgan's_laws).

Нека да проследим как се получава булевият израз ```outOfSemicircle```. Първо да построим израз ```inSemicircle```, който казва дали точка е вътре в полукръга. Вътре в полукръга означава включително прекъснатата дъга, но без черната отсечка IH. Тоест ```inSemicircle = (pointX*pointX + pointY*pointY <= 4 && pointX < 0)```. Сега ```outOfSemicircle``` е отрицанието на ```inSemicircle```. Следователно според закона на Де Морган: ```outOfSemicircle=(!(pointX*pointX + pointY*pointY <= 4) || !(pointX < 0))=(pointX*pointX + pointY*pointY > 4 || pointX >=0)```. Другите булеви изрази се получават аналогично.

#### Примери ####

```c++
0 -1
// -> true

-1.74 1.54
// -> true

-0.8 1.86
// -> false

0 0.54
// -> false

1.72 -2.46
// -> false
```

### Задача 2 ###

Два триъгълника са зададени с координатите на върховете си. Да се
провери дали те са еднакви.

#### ВАЖНО ####

На упражненията дадохме две идеи за решение на задачата:

* [Първата идея](https://github.com/gshopov/up2013/blob/master/exercises/exercise3/problem2_solution1.cpp) беше да подредим страните на всеки триъгълник по-дължините им. После да сравняваме най-късата страна на първия триъгълник с най-късата на втория и т.н. **Това е ОК**.
* [Втората идея](https://github.com/gshopov/up2013/blob/master/exercises/exercise3/problem2_solution2.cpp) беше да проверяваме за всяка от страните на първия триъгълник дали е равна по дължина на някоя от страните на втория триъгълник. **Това е ГРЕШНО**. Например, ако страните на първия триъгълник са с дължини 3, 3, 3, а на втория 3, 4, 5, това решение ще каже, че двата триъгълника са еднакви, а те не са.

#### Примери ####

```c++
-2.62 0.74
0.84 -2.32
1.62 3.06
// Тук започват координатите на точките на втория триъгълник
1.61 -1.25
5.07 -4.31
5.85 1.07
// -> true

1.61 -1.25
5.07 -4.31
5.85 1.07
// Тук започват координатите на точките на втория триъгълник
-0.59 -4.55
2.87 -7.61
3.65 -2.23
// -> true

-2.62 0.74
1.62 3.06
-0.59 -4.55
// Тук започват координатите на точките на втория триъгълник
1.61 -1.25
0.84 -2.32
5.85 1.07
// -> false

-2.62 0.74
1.61 -1.25
0.84 -2.32
// Тук започват координатите на точките на втория триъгълник
3.65 -2.23
5.07 -4.31
2.87 -7.61
// -> false
```

### Задача 3 ###

Напишете програма, която по, въведена от клавиатурата, година отпечатва дали тя е високосна или не. Разгледайте и двете решения и помислете защо те са еквивалентни специално за тази задача. Обяснението е в [коментара](https://github.com/gshopov/up2013/tree/master/exercises/exercise3#%D0%9A%D0%BE%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80-%D0%BD%D0%B0-%D0%B4%D0%B2%D0%B5%D1%82%D0%B5-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F).

#### Коментар на двете решения ####

Първо е важно да запомните, че приоритетът на ```&&``` е по-висок от този на ```||```. Може да мислите за ```&&``` като за умножение, а за ```||``` като за събиране. Ако в израз с операции умножение и събиране няма скоби, първо се умножава, а после се събира. Съответно, ако има скоби, първо се пресмята това в скобите.

Нека имаме два булеви израза ```A && B || C``` и ```A && (B || C)```, където ```A```, ```B``` и ```C``` са произволни. Нека да проследим стойността на булевите изрази за различни стойности на ```A```, ```B``` и ```C```.

№   |A      | B     | C     | A && B &#124;&#124; C | A && (B &#124;&#124; C)|
:---|:-----:|:-----:|:-----:|:---------------------:|:------------------:|
1   |true   | false | false | false        | false         |
2   |true   | false | true  | true         | true          |
3   |true   | true  | false | true         | true          |
4   |true   | true  | true  | true         | true          |
5   |false  | false | false | false        | false         |
**6**|**false**|**false**|**true**|**true**|**false**|
7   |false  | true  | false | false        | false         |
**8**|**false**|**true**|**true**|**true**|**false**|

Забелязваме, че единствените разлики в стойностите на изразите са в 6-ти и 8-ми ред от таблицата.

Сега да вземем конкретни изрази за ```A```, ```B``` и ```C```. Нека: ```A = (year % 4 == 0)```, ```B = (year % 100 != 0)``` и ```C = (year % 4000 == 0)```.

Сега 6-ти ред от таблицата казва: ако ```year``` не се дели на **4**, не се дели на **100** и се дели на **400**. Но това няма как да се случи, тъй като, ако ```year``` не се дели на **4** и не се дели на **100**, то ```year``` няма да се дели и на **400**. Тоест условията от 6-ти ред от таблицата никога няма да са в сила за нашата конкретна задача и можем да го игнорираме.

Аналогично е разсъждението и за 8-мия ред. Ако ```year``` не се дели на **4**, то няма как ```year``` да се дели на **100**. Следователно и този ред може да се игнорира, тъй като е непостижим в нашия случай.

Тоест таблицата за нашата задача е като тази горе, но без 6-ти и 8-ми ред, а тази нова таблица показва, че двата израза получават еднакви стойности при всички възможни стойности на ```A```, ```B``` и ```C```.

#### Примери ####

```c++
1952
// -> 1952 is a leap year!

2180
// -> 2180 is a leap year!

1700
// -> 1700 is not a leap year!

2396
// -> 2396 is a leap year!

2300
// -> 2300 is not a leap year!
```
